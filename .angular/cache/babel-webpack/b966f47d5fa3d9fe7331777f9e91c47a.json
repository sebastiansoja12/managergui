{"ast":null,"code":"import { filter, switchMap, distinctUntilChanged, shareReplay, map } from 'rxjs/operators';\nimport { ɵɵdefineInjectable, Injectable, InjectionToken, Inject, PLATFORM_ID, NgZone, ɵɵinject, Optional, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { Subject, of } from 'rxjs';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nvar StorageStrategies = /*#__PURE__*/(() => {\n  (function (StorageStrategies) {\n    StorageStrategies[\"Local\"] = \"local_strategy\";\n    StorageStrategies[\"Session\"] = \"session_strategy\";\n    StorageStrategies[\"InMemory\"] = \"in_memory_strategy\";\n  })(StorageStrategies || (StorageStrategies = {}));\n\n  return StorageStrategies;\n})();\n\nclass CompatHelper {\n  static isStorageAvailable(storage) {\n    let available = true;\n\n    try {\n      if (typeof storage === 'object') {\n        storage.setItem('test-storage', 'foobar');\n        storage.removeItem('test-storage');\n      } else available = false;\n    } catch (e) {\n      available = false;\n    }\n\n    return available;\n  }\n\n}\n\nfunction noop() {}\n\nconst DefaultPrefix = 'ngx-webstorage';\nconst DefaultSeparator = '|';\nconst DefaultIsCaseSensitive = false;\nlet StorageKeyManager = /*#__PURE__*/(() => {\n  class StorageKeyManager {\n    static normalize(raw) {\n      raw = StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();\n      return `${StorageKeyManager.prefix}${StorageKeyManager.separator}${raw}`;\n    }\n\n    static isNormalizedKey(key) {\n      return key.indexOf(StorageKeyManager.prefix + StorageKeyManager.separator) === 0;\n    }\n\n    static setPrefix(prefix) {\n      StorageKeyManager.prefix = prefix;\n    }\n\n    static setSeparator(separator) {\n      StorageKeyManager.separator = separator;\n    }\n\n    static setCaseSensitive(enable) {\n      StorageKeyManager.isCaseSensitive = enable;\n    }\n\n    static consumeConfiguration(config) {\n      if ('prefix' in config) this.setPrefix(config.prefix);\n      if ('separator' in config) this.setSeparator(config.separator);\n      if ('caseSensitive' in config) this.setCaseSensitive(config.caseSensitive);\n    }\n\n  }\n\n  StorageKeyManager.prefix = DefaultPrefix;\n  StorageKeyManager.separator = DefaultSeparator;\n  StorageKeyManager.isCaseSensitive = DefaultIsCaseSensitive;\n  return StorageKeyManager;\n})();\n\nclass SyncStorage {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  retrieve(key) {\n    let value;\n    this.strategy.get(StorageKeyManager.normalize(key)).subscribe(result => value = typeof result === 'undefined' ? null : result);\n    return value;\n  }\n\n  store(key, value) {\n    this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);\n    return value;\n  }\n\n  clear(key) {\n    if (key !== undefined) this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);else this.strategy.clear().subscribe(noop);\n  }\n\n  getStrategyName() {\n    return this.strategy.name;\n  }\n\n  observe(key) {\n    key = StorageKeyManager.normalize(key);\n    return this.strategy.keyChanges.pipe(filter(changed => changed === null || changed === key), switchMap(() => this.strategy.get(key)), distinctUntilChanged(), shareReplay());\n  }\n\n}\n\nclass AsyncStorage {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  retrieve(key) {\n    return this.strategy.get(StorageKeyManager.normalize(key)).pipe(map(value => typeof value === 'undefined' ? null : value));\n  }\n\n  store(key, value) {\n    return this.strategy.set(StorageKeyManager.normalize(key), value);\n  }\n\n  clear(key) {\n    return key !== undefined ? this.strategy.del(StorageKeyManager.normalize(key)) : this.strategy.clear();\n  }\n\n  getStrategyName() {\n    return this.strategy.name;\n  }\n\n  observe(key) {\n    key = StorageKeyManager.normalize(key);\n    return this.strategy.keyChanges.pipe(filter(changed => changed === null || changed === key), switchMap(() => this.strategy.get(key)), distinctUntilChanged(), shareReplay());\n  }\n\n}\n\nlet StrategyCacheService = /*#__PURE__*/(() => {\n  class StrategyCacheService {\n    constructor() {\n      this.caches = {};\n    }\n\n    get(strategyName, key) {\n      return this.getCacheStore(strategyName)[key];\n    }\n\n    set(strategyName, key, value) {\n      this.getCacheStore(strategyName)[key] = value;\n    }\n\n    del(strategyName, key) {\n      delete this.getCacheStore(strategyName)[key];\n    }\n\n    clear(strategyName) {\n      this.caches[strategyName] = {};\n    }\n\n    getCacheStore(strategyName) {\n      if (strategyName in this.caches) return this.caches[strategyName];\n      return this.caches[strategyName] = {};\n    }\n\n  }\n\n  StrategyCacheService.ɵfac = function StrategyCacheService_Factory(t) {\n    return new (t || StrategyCacheService)();\n  };\n\n  StrategyCacheService.ɵprov = ɵɵdefineInjectable({\n    factory: function StrategyCacheService_Factory() {\n      return new StrategyCacheService();\n    },\n    token: StrategyCacheService,\n    providedIn: \"root\"\n  });\n  return StrategyCacheService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LOCAL_STORAGE = new InjectionToken('window_local_storage');\n\nfunction getLocalStorage() {\n  return typeof window !== 'undefined' ? window.localStorage : null;\n}\n\nconst LocalStorageProvider = {\n  provide: LOCAL_STORAGE,\n  useFactory: getLocalStorage\n};\nconst SESSION_STORAGE = new InjectionToken('window_session_storage');\n\nfunction getSessionStorage() {\n  return typeof window !== 'undefined' ? window.sessionStorage : null;\n}\n\nconst SessionStorageProvider = {\n  provide: SESSION_STORAGE,\n  useFactory: getSessionStorage\n};\n\nclass BaseSyncStorageStrategy {\n  constructor(storage, cache) {\n    this.storage = storage;\n    this.cache = cache;\n    this.keyChanges = new Subject();\n  }\n\n  get isAvailable() {\n    if (this._isAvailable === undefined) this._isAvailable = CompatHelper.isStorageAvailable(this.storage);\n    return this._isAvailable;\n  }\n\n  get(key) {\n    let data = this.cache.get(this.name, key);\n    if (data !== undefined) return of(data);\n\n    try {\n      const item = this.storage.getItem(key);\n\n      if (item !== null) {\n        data = JSON.parse(item);\n        this.cache.set(this.name, key, data);\n      }\n    } catch (err) {\n      console.warn(err);\n    }\n\n    return of(data);\n  }\n\n  set(key, value) {\n    const data = JSON.stringify(value);\n    this.storage.setItem(key, data);\n    this.cache.set(this.name, key, value);\n    this.keyChanges.next(key);\n    return of(value);\n  }\n\n  del(key) {\n    this.storage.removeItem(key);\n    this.cache.del(this.name, key);\n    this.keyChanges.next(key);\n    return of(null);\n  }\n\n  clear() {\n    this.storage.clear();\n    this.cache.clear(this.name);\n    this.keyChanges.next(null);\n    return of(null);\n  }\n\n}\n\nclass LocalStorageStrategy extends BaseSyncStorageStrategy {\n  constructor(storage, cache, platformId, zone) {\n    super(storage, cache);\n    this.storage = storage;\n    this.cache = cache;\n    this.platformId = platformId;\n    this.zone = zone;\n    this.name = LocalStorageStrategy.strategyName;\n    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();\n  }\n\n  listenExternalChanges() {\n    window.addEventListener('storage', event => this.zone.run(() => {\n      if (event.storageArea !== this.storage) return;\n      const key = event.key;\n      if (key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);\n      this.keyChanges.next(key);\n    }));\n  }\n\n}\n\nLocalStorageStrategy.ɵfac = function LocalStorageStrategy_Factory(t) {\n  return new (t || LocalStorageStrategy)(ɵngcc0.ɵɵinject(LOCAL_STORAGE), ɵngcc0.ɵɵinject(StrategyCacheService), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nLocalStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: LocalStorageStrategy,\n  factory: LocalStorageStrategy.ɵfac\n});\nLocalStorageStrategy.strategyName = StorageStrategies.Local;\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass SessionStorageStrategy extends BaseSyncStorageStrategy {\n  constructor(storage, cache, platformId, zone) {\n    super(storage, cache);\n    this.storage = storage;\n    this.cache = cache;\n    this.platformId = platformId;\n    this.zone = zone;\n    this.name = SessionStorageStrategy.strategyName;\n    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();\n  }\n\n  listenExternalChanges() {\n    window.addEventListener('storage', event => this.zone.run(() => {\n      if (event.storageArea !== this.storage) return;\n      const key = event.key;\n      if (event.key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);\n      this.keyChanges.next(key);\n    }));\n  }\n\n}\n\nSessionStorageStrategy.ɵfac = function SessionStorageStrategy_Factory(t) {\n  return new (t || SessionStorageStrategy)(ɵngcc0.ɵɵinject(SESSION_STORAGE), ɵngcc0.ɵɵinject(StrategyCacheService), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nSessionStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: SessionStorageStrategy,\n  factory: SessionStorageStrategy.ɵfac\n});\nSessionStorageStrategy.strategyName = StorageStrategies.Session;\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass InMemoryStorageStrategy {\n  constructor(cache) {\n    this.cache = cache;\n    this.keyChanges = new Subject();\n    this.isAvailable = true;\n    this.name = InMemoryStorageStrategy.strategyName;\n  }\n\n  get(key) {\n    return of(this.cache.get(this.name, key));\n  }\n\n  set(key, value) {\n    this.cache.set(this.name, key, value);\n    this.keyChanges.next(key);\n    return of(value);\n  }\n\n  del(key) {\n    this.cache.del(this.name, key);\n    this.keyChanges.next(key);\n    return of(null);\n  }\n\n  clear() {\n    this.cache.clear(this.name);\n    this.keyChanges.next(null);\n    return of(null);\n  }\n\n}\n\nInMemoryStorageStrategy.ɵfac = function InMemoryStorageStrategy_Factory(t) {\n  return new (t || InMemoryStorageStrategy)(ɵngcc0.ɵɵinject(StrategyCacheService));\n};\n\nInMemoryStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: InMemoryStorageStrategy,\n  factory: InMemoryStorageStrategy.ɵfac\n});\nInMemoryStorageStrategy.strategyName = StorageStrategies.InMemory;\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst STORAGE_STRATEGIES = new InjectionToken('STORAGE_STRATEGIES');\nconst Strategies = [{\n  provide: STORAGE_STRATEGIES,\n  useClass: InMemoryStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: LocalStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: SessionStorageStrategy,\n  multi: true\n}];\nconst StorageStrategyStubName = 'stub_strategy';\n\nclass StorageStrategyStub {\n  constructor(name) {\n    this.keyChanges = new Subject();\n    this.store = {};\n    this._available = true;\n    this.name = name || StorageStrategyStubName;\n  }\n\n  get isAvailable() {\n    return this._available;\n  }\n\n  get(key) {\n    return of(this.store[key]);\n  }\n\n  set(key, value) {\n    this.store[key] = value;\n    this.keyChanges.next(key);\n    return of(value);\n  }\n\n  del(key) {\n    delete this.store[key];\n    this.keyChanges.next(key);\n    return of(null);\n  }\n\n  clear() {\n    this.store = {};\n    this.keyChanges.next(null);\n    return of(null);\n  }\n\n}\n\nclass StorageStub {\n  constructor() {\n    this.store = {};\n  }\n\n  get length() {\n    return Object.keys(this.store).length;\n  }\n\n  clear() {\n    this.store = {};\n  }\n\n  getItem(key) {\n    return this.store[key] || null;\n  }\n\n  key(index) {\n    return Object.keys(this.store)[index];\n  }\n\n  removeItem(key) {\n    delete this.store[key];\n  }\n\n  setItem(key, value) {\n    this.store[key] = value;\n  }\n\n}\n\nconst InvalidStrategyError = 'invalid_strategy';\nlet StrategyIndex = /*#__PURE__*/(() => {\n  class StrategyIndex {\n    constructor(strategies) {\n      this.strategies = strategies;\n      this.registration$ = new Subject();\n      if (!strategies) strategies = [];\n      this.strategies = strategies.reverse().map((strategy, index, arr) => strategy.name).map((name, index, arr) => arr.indexOf(name) === index ? index : null).filter(index => index !== null).map(index => strategies[index]);\n    }\n\n    static get(name) {\n      if (!this.isStrategyRegistered(name)) throw Error(InvalidStrategyError);\n      let strategy = this.index[name];\n\n      if (!strategy.isAvailable) {\n        strategy = this.index[StorageStrategies.InMemory];\n      }\n\n      return strategy;\n    }\n\n    static set(name, strategy) {\n      this.index[name] = strategy;\n    }\n\n    static clear(name) {\n      if (name !== undefined) delete this.index[name];else this.index = {};\n    }\n\n    static isStrategyRegistered(name) {\n      return name in this.index;\n    }\n\n    static hasRegistredStrategies() {\n      return Object.keys(this.index).length > 0;\n    }\n\n    getStrategy(name) {\n      return StrategyIndex.get(name);\n    }\n\n    indexStrategies() {\n      this.strategies.forEach(strategy => this.register(strategy.name, strategy));\n    }\n\n    indexStrategy(name, overrideIfExists = false) {\n      if (StrategyIndex.isStrategyRegistered(name) && !overrideIfExists) return StrategyIndex.get(name);\n      const strategy = this.strategies.find(strategy => strategy.name === name);\n      if (!strategy) throw new Error(InvalidStrategyError);\n      this.register(name, strategy, overrideIfExists);\n      return strategy;\n    }\n\n    register(name, strategy, overrideIfExists = false) {\n      if (!StrategyIndex.isStrategyRegistered(name) || overrideIfExists) {\n        StrategyIndex.set(name, strategy);\n        this.registration$.next(name);\n      }\n    }\n\n  }\n\n  StrategyIndex.ɵfac = function StrategyIndex_Factory(t) {\n    return new (t || StrategyIndex)(ɵngcc0.ɵɵinject(STORAGE_STRATEGIES, 8));\n  };\n\n  StrategyIndex.index = {};\n  StrategyIndex.ɵprov = ɵɵdefineInjectable({\n    factory: function StrategyIndex_Factory() {\n      return new StrategyIndex(ɵɵinject(STORAGE_STRATEGIES, 8));\n    },\n    token: StrategyIndex,\n    providedIn: \"root\"\n  });\n  return StrategyIndex;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LocalStorageService extends SyncStorage {}\n\nfunction buildService(index) {\n  const strategy = index.indexStrategy(StorageStrategies.Local);\n  return new SyncStorage(strategy);\n}\n\nconst LocalStorageServiceProvider = {\n  provide: LocalStorageService,\n  useFactory: buildService,\n  deps: [StrategyIndex]\n};\n\nclass SessionStorageService extends SyncStorage {}\n\nfunction buildService$1(index) {\n  const strategy = index.indexStrategy(StorageStrategies.Session);\n  return new SyncStorage(strategy);\n}\n\nconst SessionStorageServiceProvider = {\n  provide: SessionStorageService,\n  useFactory: buildService$1,\n  deps: [StrategyIndex]\n};\n\nclass DecoratorBuilder {\n  static buildSyncStrategyDecorator(strategyName, prototype, propName, key, defaultValue = null) {\n    const rawKey = key || propName;\n    let storageKey;\n    Object.defineProperty(prototype, propName, {\n      get: function () {\n        let value;\n        StrategyIndex.get(strategyName).get(getKey()).subscribe(result => value = result);\n        return value === undefined ? defaultValue : value;\n      },\n      set: function (value) {\n        StrategyIndex.get(strategyName).set(getKey(), value).subscribe(noop);\n      }\n    });\n\n    function getKey() {\n      if (storageKey !== undefined) return storageKey;\n      return storageKey = StorageKeyManager.normalize(rawKey);\n    }\n  }\n\n}\n\nfunction LocalStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Local, prototype, propName, key, defaultValue);\n  };\n}\n\nfunction SessionStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Session, prototype, propName, key, defaultValue);\n  };\n}\n\nconst Services = [LocalStorageServiceProvider, SessionStorageServiceProvider];\nconst LIB_CONFIG = new InjectionToken('ngx_webstorage_config');\n\nfunction appInit(index) {\n  index.indexStrategies();\n  return () => StrategyIndex.index;\n}\n\nlet NgxWebstorageModule = /*#__PURE__*/(() => {\n  class NgxWebstorageModule {\n    constructor(index, config) {\n      if (config) StorageKeyManager.consumeConfiguration(config);else console.error('NgxWebstorage : Possible misconfiguration (The forRoot method usage is mandatory since the 3.0.0)');\n    }\n\n    static forRoot(config = {}) {\n      return {\n        ngModule: NgxWebstorageModule,\n        providers: [{\n          provide: LIB_CONFIG,\n          useValue: config\n        }, LocalStorageProvider, SessionStorageProvider, ...Services, ...Strategies, {\n          provide: APP_INITIALIZER,\n          useFactory: appInit,\n          deps: [StrategyIndex],\n          multi: true\n        }]\n      };\n    }\n\n  }\n\n  NgxWebstorageModule.ɵfac = function NgxWebstorageModule_Factory(t) {\n    return new (t || NgxWebstorageModule)(ɵngcc0.ɵɵinject(StrategyIndex), ɵngcc0.ɵɵinject(LIB_CONFIG, 8));\n  };\n\n  NgxWebstorageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxWebstorageModule\n  });\n  NgxWebstorageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return NgxWebstorageModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-webstorage\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AsyncStorage, CompatHelper, InMemoryStorageStrategy, InvalidStrategyError, LIB_CONFIG, LOCAL_STORAGE, LocalStorage, LocalStorageService, LocalStorageStrategy, NgxWebstorageModule, SESSION_STORAGE, STORAGE_STRATEGIES, SessionStorage, SessionStorageService, SessionStorageStrategy, StorageStrategies, StorageStrategyStub, StorageStrategyStubName, StorageStub, StrategyCacheService, StrategyIndex, SyncStorage, appInit, getLocalStorage as ɵa, LocalStorageProvider as ɵb, getSessionStorage as ɵc, SessionStorageProvider as ɵd, Strategies as ɵe, buildService as ɵf, LocalStorageServiceProvider as ɵg, buildService$1 as ɵh, SessionStorageServiceProvider as ɵi, BaseSyncStorageStrategy as ɵj, STORAGE_STRATEGIES as ɵl, Services as ɵn }; //# sourceMappingURL=ngx-webstorage.js.map","map":null,"metadata":{},"sourceType":"module"}